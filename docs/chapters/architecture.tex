\chapter{Architecture}

\section{High Level View}
\begin{center}
\begin{figure}
  \begin{tikzpicture}
    \coordinate(origin);
    \node(core) at (origin) [draw] {Generate tests};
    \node(control) at ([left=3cm] core) [draw] {Load classes};
    \node(output) at ([right=3cm] core) [draw] {Write tests};
    \node(compare) at ([right=3cm] output) [draw] {Compare versions};
    \node(gui) at ([left=2cm,above=1cm] control) [draw] {GUI};
    \node(cli) at ([left=2cm,below=1cm] control) [draw] {CLI};

    \draw[->] (control) -> (core);
    \draw[->] (core) -> (output);
    \draw[->] (output) -> (compare);
    \draw[->] (gui) -> (control);
    \draw[->] (cli) -> (control);
  \end{tikzpicture}
\caption{A short summary of the control flow of SpLATS}
\label{fig:Architecture_HighLevel}
\end{figure}
\end{center}

  Figure \ref{fig:Architecture_HighLevel} shows the overall view of the system. There is a test generator, an output module, a wrapper to control the two, and either a graphical or command-line interface to control that.

    There's an inner core that generates the tests, an outer layer that controls it and handles file input and output, and a wrapper to pass options to the outer layer. These sections are explained in more detail in the following section.
    
\section{Lower Level Architecture}

  \begin{center}
  \begin{figure}
  \input{images/splatsflow}
  \caption{A more in-depth summary of the control flow of SpLATS}
  \label{fig:Architecture_LowLevel}
  \end{figure}
  \end{center}
  Figure ~\ref{fig:Architecture_LowLevel} shows the workflow at a more in-depth level.
  \begin{enumerate}
  \small
  \item The user starts a UI of their choice, and passes in the file or files to be tested, a directory to put the finished tests, a traversal method and any parameters for that method.
    The interface then starts the TestController, which creates the output directory if needbe and loads the input files and their relevant classes.
  \item The TestController then initializes a Generator for each class, with the traversal method and parameters.
  \item The Generator talks to the traversal method.
  \item The traversal method responds to the Generator.
  \item Every Test produced by the Generator is sent to the TestController.
  \item The Tests are sent to TestFile, which wraps the tests with the necessary code to be run by Ruby's Test::Unit framework.
  \end{enumerate}
  
  \subsection{User Interface}
  \setcounter{secnumdepth}{4}
  \subsubsection{Command Line Interface}
  \subsubsection{Graphical User Interface (GUI)}
  \paragraph{Choice of framework}
  The GUI was initially implemented with a stand-alone Ruby program by \_why called Shoes\footnote{\url{http://shoesrb.com/}}. This came shipped with its own version of Ruby. After some discussion, it was decided that we should try to use as many Gems\footnote{Ruby's equivalent of libraries} as possible, rather than stand-alone programs which the user must install. For this reason, the GUI was ported over to Green Shoes\footnote{\url{https://github.com/ashbb/green_shoes}} which can be installed by the standard "gem install" command, loaded in SpLATS by "require green\_shoes" and run as a normal Ruby file.
  
  \paragraph{Design}
  The GUI was designed to be minimalist with as few buttons as possible. As no one in the group would proclaim to be a designer, the look of the GUI is minimalist as well. The images are used to illustrate the workflow the user goes through when first loading the GUI.
  
  Figure \ref{fig:GUI_Page1} shows the page the user sees when they first load a file. Before the file is loaded, the button saying "Load first version of the code" is all they see. There is no other information on the first page, because it is assumed that the user wants to just begin testing and they already know what the program does. The "file open" dialog will not allow the user to cancel, nor allow the user to select a file which isn't '.rb'. Once a valid file is loaded, the "next" button and the text box appear. The text box is there to show the user what the inside of the file looks like, just so they are certain that they have loaded the correct version to test. In future implementations of SpLATS, it would be possible to make this file box editable and saveable, but that does not appear high on the list of priorities.
  
  Figure \ref{fig:GUI_Page2} is the same as the first page, only for the second version of the code.
  Figure \ref{fig:GUI_Page3a} show the options the user then has to traverse the code. As discussed in the traversal methods, SpLATS currently only implements three traversal methods, but more can be added easily into the GUI. As the user changes their selection in the drop-down box, the options in the space below change to update inputs. Figures \ref{fig:GUI_Page3b} and \ref{fig:GUI_Page3c} illustrate this. The "next" button on third page doesn't work unless the extra parameters for "Random" and "Depth-Limited" are correct. Figure \ref{fig:GUI_Page3d} shows what the user sees when they've entered an invalid seed.
  \begin{center}
    \graphic{width=0.5\textwidth}{page_1}{First page - the user must load version 1}{fig:GUI_Page1}
    \graphic{width=0.5\textwidth}{page_2}{Second page - the user must load version 2}{fig:GUI_Page2}
    \graphic{width=0.5\textwidth}{page_3a}{Third page default selection - Depth-Limited}{fig:GUI_Page3a}
    \graphic{width=0.5\textwidth}{page_3b}{Third page options}{fig:GUI_Page3b}
    \graphic{width=0.5\textwidth}{page_3c}{Third page random with seed}{fig:GUI_Page3c}
    \graphic{width=0.5\textwidth}{page_3d}{Third page seed input error}{fig:GUI_Page3d}
  \end{center}

  \subsection{Output}
    When tests are generated by the Generator, they are added, line by line, to a Test object, which stores them in an internal representation called TestLine.
    This Test object is then passed to a TestFile, a wrapper around the built-in IO::File, which writes it to file.

    Initially, the Tests were stored until the Generator had finished, before being wrapped and outputted through a regular File.
    However, Tests store all the Mock objects associated with them, and thus this was changed so they could be garbage collected as soon as possible to reduce memory footprint.
    
    
