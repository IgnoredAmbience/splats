\chapter{Architecture}

\section{High Level View}
\begin{center}
\begin{figure}
  \begin{tikzpicture}
    \coordinate(origin);
    \node(core) at (origin) [draw] {Generate tests};
    \node(control) at ([left=3cm] core) [draw] {Load classes};
    \node(output) at ([right=3cm] core) [draw] {Write tests};
    \node(compare) at ([right=3cm] output) [draw] {Compare versions};
    \node(gui) at ([left=2cm,above=1cm] control) [draw] {GUI};
    \node(cli) at ([left=2cm,below=1cm] control) [draw] {CLI};

    \draw[->] (control) -> (core);
    \draw[->] (core) -> (output);
    \draw[->] (output) -> (compare);
    \draw[->] (gui) -> (control);
    \draw[->] (cli) -> (control);
  \end{tikzpicture}
\caption{A short summary of the control flow of SpLATS}
\label{fig:Architecture_HighLevel}
\end{figure}
\end{center}

  Figure \ref{fig:Architecture_HighLevel} shows the overall view of the system. There is a test generator, an output module, a wrapper to control the two, and either a graphical or command-line interface to control that.

    There's an inner core that generates the tests, an outer layer that controls it and handles file input and output, and a wrapper to pass options to the outer layer. These sections are explained in more detail in the following section.
    
\section{Lower Level Architecture}

  \begin{center}
  \begin{figure}
  \input{images/splatsflow}
  \caption{A more in-depth summary of the control flow of SpLATS}
  \label{fig:Architecture_LowLevel}
  \end{figure}
  \end{center}
  Figure ~\ref{fig:Architecture_LowLevel} shows the workflow at a more in-depth level.
  \begin{enumerate}
  \small
  \item The user starts a UI of their choice, and passes in the file or files to be tested, a directory to put the finished tests, a traversal method and any parameters for that method.
    The interface then starts the TestController, which creates the output directory if one is needed, and loads the input files and their relevant classes.
  \item The TestController then initialises a Generator for each class, with the traversal method and parameters.
  \item The Generator talks to the traversal method.
  \item The traversal method responds to the Generator.
  \item Every Test produced by the Generator is sent to the TestController.
  \item If the tests are being generated for a single file, the tests are sent to TestFile, which wraps the tests with the necessary code to be run by Ruby's Test::Unit framework. 
  \item If the tests are being generated to compare two files, the tests are generated and run in memory without being saved to disk.
  \end{enumerate}
  
  \subsection{User Interface}
  \setcounter{secnumdepth}{4}
  \subsubsection{Command Line Interface (CLI)}
  
  The CLI is a simple wrapper used to interact with SpLATS. 
  It uses the built-in Ruby OptionParser class, which allowed us to simply specify and analyse the options that the user enters. 
  The CLI's purpose is to interpret the entered arguments and use them to create the correct traversal object, and to pass the relevant file and output directory to the controller.
  As it only uses text commands for input, it would be easy for a user to automate the process of testing using a script, so that many tests can be automatically performed without the user needing to manually invoke them every time.
  If the user enters an invalid command then the CLI will show an error messsage along with an explanation of the commands.
  
  \subsubsection{Graphical User Interface (GUI)}
  \paragraph{Choice of framework}
  When researching which GUI to use, the vast majority of those for Ruby are either no longer supported, have a non-native look about them, or work only with Mac or Windows. Since the majority of the group are Unix users, the latter constraint meant that there were only a few to choose from. There is a page on wikipedia comparing the various frameworks on offer\footnote{\url{http://en.wikibooks.org/wiki/Ruby_Programming/GUI_Toolkit_Modules}}, and from this page (and other forums) Ruby Shoes unanimously stood out as it is extremely quick to load elements and has a shallow learning curve.
  Shoes is a stand-alone Ruby program Shoes\footnote{\url{http://shoesrb.com/}}. This came shipped with its own version of Ruby. After some discussion, it was decided that we should try to use as many Gems\footnote{Ruby's equivalent of libraries} as possible, rather than stand-alone programs which the user must install. For this reason, the GUI was ported over to Green Shoes\footnote{\url{https://github.com/ashbb/green_shoes}} which can be installed by the standard "gem install" command, loaded in SpLATS by "require green\_shoes" and run as a normal Ruby file.
  
  \paragraph{Design}
  The GUI was designed to be minimalist with as few buttons as possible. As no one in the group proclaimed to be a designer, the look of the GUI is minimalist as well. The images are used to illustrate the workflow the user goes through when first loading the GUI.
  
  Figure \ref{fig:GUI_Page1} shows the page the user sees when they first open the GUI. This gives them the option to load the version of the code to generate tests for. Before the file is loaded, the button saying \verb+Load first version of the code+ is all they see. There is no other information on the first page, because it is assumed that the user wants to just begin testing and they already know what the program does. The \verb+file open+ dialog will not allow the user to cancel, nor allow the user to select a file which isn't '.rb'. Once a valid file is loaded, the \verb+next+ button and the text box appear. The text box is there to show the user what the inside of the file looks like, just so they are certain that they have loaded the correct version to test. There is a bug in Green Shoes, where the scroll bar doesn't appear on these text boxes, however they are scrollable with the mouse. The issues encountered with Green Shoes will be discussed in the "Problems" section. In future implementations of SpLATS, it would be possible to make this file box editable and writeable, but that is not high on the list of priorities.
Figure \ref{fig:GUI_Page2} is the same as the first page, only for the second version of the code.
  
  \begin{figure}
    \centering
    \subfloat[Load version 1]{\label{fig:GUI_Page1}\includegraphics[width=0.4\textwidth]{page_1}}                
    \subfloat[Load version 2]{\label{fig:GUI_Page2}\includegraphics[width=0.4\textwidth]{page_2}}
    \caption{These pages are displayed when the user loads files to test}
    \label{fig:GUI_LoadVersions}
  \end{figure}
  
  Figure \ref{fig:GUI_Page3a} show the options the user then has to traverse the code. As discussed in the traversal methods, SpLATS currently only implements three traversal methods, but more can be added easily into the GUI. As the user changes their selection in the drop-down box, the options in the space below change to update inputs. Figures \ref{fig:GUI_Page3b} and \ref{fig:GUI_Page3c} illustrate this. The "next" button on third page doesn't do anything unless the extra parameters for "Random" and "Depth-Limited" are correct. Figure \ref{fig:GUI_Page3d} shows what the user sees when they've entered an invalid seed.
  
  \begin{figure}
    \centering
    \subfloat[Default traversal page]{\label{fig:GUI_Page3a}\includegraphics[width=0.4\textwidth]{page_3a}}
    \subfloat[Traversal options]{\label{fig:GUI_Page3b}\includegraphics[width=0.4\textwidth]{page_3b}}
    \caption{The page the user sees when selecting a traversal method}
    \label{fig:GUI_SelectTraversal1}
  \end{figure}
  
  \begin{figure}
    \centering
    \subfloat[Random traversal]{\label{fig:GUI_Page3c}\includegraphics[width=0.4\textwidth]{page_3c}}
    \subfloat[Error in input]{\label{fig:GUI_Page3d}\includegraphics[width=0.4\textwidth]{page_3d}}
    \caption{Traversal page}
    \label{fig:GUI_SelectTraversal2}
  \end{figure}
  
  Once the user has input the correct information and they click "next", if they have selected "depth-limited" or "random" as the traversal methods, they will only see a page saying "generating tests", an alert pops up saying "testing complete" and SpLATS GUI will exit. It was decided not to draw graphs for these methods because the graphs will be extremely large.
  
  If the user has selected "Manual", then the GUI becomes more interesting. In order to have the GUI communicating with the code running SpLATS, threads were initially chosen. In theory, one thread would start the SpLATS process, and then when the user needed to give input, the thread would switch back to the GUI to ask for the user, the user would give input and so on until the end of the generation. The problem with threads is that they are determined by the thread scheduler, and it is difficult to time the threads and dictate exactly which thread should start when. This problem was overcome by using Ruby's in-built Fiber module. This is a much more lightweight implementation of Threads, but they don't need a scheduler, each Fiber has its own stack and the Fibers need to be specifically started and stopped. The three of these in combination were exactly what was needed to make the GUI run. Without the overhead of a scheduler, the GUI is extremely lightweight. The stack means that variables could be passed between Fibers, so the options available to the user are sent from the controller to the GUI, and the user's choice sent from the GUI to the controller. Figure \ref{fig:GUI_Page4a} shows the first choice the user will always have when in manual mode. They have to select which parameters to give to the initialise method (if there are any). When debugging the human traversal in the CLI, the context of the decision being made was difficult to deduce. The design decision was made to show the user the relevant line in the code, plus or minus five lines.
  
  \begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{page_4a}
    \caption{Manual traversal: "initialise" parameter choice}
    \label{fig:GUI_Page4a}
  \end{figure}
  
  \begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{page_4b}
    \caption{Manual traversal: "choose method" graph display of previous selections}
    \label{fig:GUI_Page4b}
  \end{figure}
  
  As the user steps down the traversal tree, they are presented a graph at each choice they have the option to make. A new window pops up, displaying a graph generated from information stored in SpLATS as the user makes their selections. The graph was designed to be a maximum of three levels deep, because otherwise displaying the user the information becomes too cumbersome. Figure \ref{fig:GUI_Page4b} shows what the user sees when they have already made decisions, and they are being asked to select the next method to generate tests for. This way the user can keep track of the methods they have selected and at what depth they are currently at.

  \subsection{Test Generator}
    The purpose of the test generator is to produce tests for a given Class
Under Test (CUT), the generator is also passed a traversal object that is used
to direct the generator's search.

    The production of tests in SpLATS can be visualised as a tree where each
node represents a choice that must be made. The choices in question are which
method to test, the values to pass that method as arguments, and any primitive
values that must be created (termed 'mock decisions') during execution of the CUT.
    The test can be considered as being split into lines each comprising of one
method, one set of arguments, and multiple mock decisions.

%TODO: Insert tree diagram

    Each time a decisions is made, the generator offers a selection of options
(in the case of methods and argument sets), or a type constraint (in the case of
values) to the traversal object. It is the traverser's responibility to track
the traversal and to direct the search as it deems best.

    Each test line is produced in 3 distinct stages, selection of a method,
selection of arguments, and execution of this test line - which causes values to
be generated.

    First, the method selection. Initially, the object must be constructed from
its class. Our lightweight Ruby assumes that the only way to construct an
object is through the use of its class' \texttt{new} method. This is given to
the traversal class as the only option to update its internal state. In
subsequent test lines, Ruby's in-built reflection is used to retrieve the
callable (public) methods on the object.

    Then, all the possible sets of arguments for the given method are produced
by examining the method's signature. The range of numbers of parameters is
determined by examining the number of required and optional parameters that the
method can take. The repeated permutation of the input values is then taken
for the range of possible input sizes. The input values to the methods under
test are either nil or a Mock object.

    Finally, the test line is executed and the result recorded. Any Mock objects
that were passed into the method are used to record the methods called upon the
arguments to the method and thus trace the data flow from the inputs to the
outputs of the methods. This aims to solve the problems associated with
determining acceptable input types under the duck typing system.

    Certain method calls upon a Mock object are defined as returning a primitive
type rather than another Mock object as Ruby expects primitives to be reuturned
in certain cases (such as numerical addition and cast operations), this also
helps to prevent an indefinitely long chain of Mock objects forming.

    Each time a a Mock object returns a value, the value returned and the other
options available at that branch point is added to the search space of the
traversals.

    If the execution of a line raises an error, further descent of the tree will
be stopped and the traversal object notified of the exception that was raised.

    After each line is generated, the traversal object is queried to see if
another line should be generated, and similarly queried after each test is
generated.

    Three traversal mechanisms have been written so far for use with SpLATS, these
are Human, Random and Breadth-first. The efficiency of each of these mechanisms
is confirmed in the evaluation system. The interface is designed so that it is
easy to write and use new traversal mechanisms and data generators.

  \subsection{Output}
    When tests are generated by the Generator, they are added, line by line, to a Test object, which stores them in an internal representation called TestLine.
    
    If SpLATS is set to only generate tests from a single input, then the Test object is passed to TestFile, a wrapper around the built-in IO::File, which is used to write to the tests to a file.
    However, if SpLATS is set to perform a regression test, then the files will not be written to disk, and instead are generated and run in memory. 
    
    Initially, the Tests were stored until the Generator had finished, before being wrapped and output to a regular File.
    However, Tests store all the Mock objects associated with them, and thus this was changed so they could be garbage collected as soon as possible to reduce memory footprint.
    
     The tests are output in the Test::Unit framework style. The FlexMock library
is used for the ability to assert that calls should be made upon the inputs to
functions and to track the source of the outputs. The FlexMock invocations are a
representation of the calls made on the SpLATS Mock objects during the test
generation stage.
