\chapter{Architecture}

\section{High Level View}

  At a high level, there is a test generator, an output module, a wrapper to control the two, and either a graphical or command-line interface to control that.
\begin{center}
\begin{figure}
  \begin{tikzpicture}
    \coordinate(origin);
    \node(core) at (origin) [draw,align=center] {Generate tests};
    \node(control) at ([left=3cm] core) [draw,align=center] {Load classes};
    \node(output) at ([right=3cm] core) [draw,align=center] {Write tests};
    \node(compare) at ([right=3cm] output) [draw,align=center] {Compare versions};
    \node(gui) at ([left=2cm,above=1cm] control) [draw,align=center] {GUI};
    \node(cli) at ([left=2cm,below=1cm] control) [draw,align=center] {CLI};

    \draw[->] (control) -> (core);
    \draw[->] (core) -> (output);
    \draw[->] (output) -> (compare);
    \draw[->] (gui) -> (control);
    \draw[->] (cli) -> (control);
  \end{tikzpicture}
\caption{A short summary of the control flow of SpLATS}
\end{figure}
\end{center}

    There's an inner core that generates the tests, an outer layer that controls it and handles file input and output, and a wrapper to pass options to the outer layer.
    
\section{Lower Level Architecture}

  \begin{center}
  \begin{figure}
  \input{images/splatsflow}
  \caption{A more in-depth summary of the control flow of SpLATS}
  \end{figure}
  \end{center}
  
  \begin{enumerate}
  \small
  \item The user starts a UI of their choice, and passes in the file or files to be tested, a directory to put the finished tests, a traversal method and any parameters for that method.
    The interface then starts the TestController, which creates the output directory if needbe and loads the input files and their relevant classes.
  \item The TestController then initializes a Generator for each class, with the traversal method and parameters.
  \item The Generator talks to the traversal method.
  \item The traversal method responds to the Generator.
  \item Every Test produced by the Generator is sent to the TestController.
  \item The Tests are sent to TestFile, which wraps the tests with the necessary code to be run by Ruby's Test::Unit framework.
  \end{enumerate}
  
  \subsection{User Interface}
  \subsubsection{Command Line Interface}
  \subsubsection{Graphical User Interface}
  \begin{center}
    \graphic{width=0.8\textwidth}{page_1}{}
    \graphic{width=0.8\textwidth}{page_2}{}
    \graphic{width=0.8\textwidth}{page_3}{}
    \graphic{width=0.8\textwidth}{page_3a}{}
    \graphic{width=0.8\textwidth}{page_3b}{OMG}
  \end{center}

  \subsection{Output}
    When tests are generated by the Generator, they are added, line by line, to a Test object, which stores them in an internal representation called TestLine.
    This Test object is then passed to a TestFile, a wrapper around the built-in IO::File, which writes it to file.

    Initially, the Tests were stored until the Generator had finished, before being wrapped and outputted through a regular File.
    However, Tests store all the Mock objects associated with them, and thus this was changed so they could be garbage collected as soon as possible to reduce memory footprint.
    
    
