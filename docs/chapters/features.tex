\chapter{Features}

\def \colwidth {0.35\textwidth}
\section{User Stories}
  Below is an extract from the first report explaining what the requirements are.
  These have been modified slightly to take into consideration how the requirements have changed as the project has evolved.
  \subsection{Minimum Requirements}
    \begin{tabular}{| c | p{\colwidth} | p{\colwidth} |}
    \hline
    \textbf{As a...} & \textbf{I need to...} & \textbf{Because...} \\
    \hline
    Ruby developer &
    Find out if two versions of my code have the same functionality &
    Any changes to the codebase should not break existing code. \\
    \hline
    Ruby developer &
    Set configuration options to select which classes and/or methods to test &
    I won't necessarily want to test the entire system \\
    \hline
    Ruby developer &
    Inspect code coverage of generated tests &
    I need to know how much of my code has been tested \\
    \hline
    Ruby developer &
    Reproduce tests &
    A test will highlight issues, I will change the code and then want to run the same tests to check the problem has disappeared. \\
    \hline
    Ruby developer &
    Use a command line interface to interact with the system &
    It's the quickest method for me to run tests and is easily automated, eg, by git bisect \\
    \hline
    \end{tabular}
  \subsection{Extensions}
    \begin{tabular}{| c | p{\colwidth} | p{\colwidth} |}
    \hline
    \textbf{As a...} & \textbf{I need to...} & \textbf{Because...} \\
    \hline
    Ruby developer &
    Use a graphical interface to interact with the system &
    If I'm not used to command line interfaces, it will be the easiest way for me to use the system. \\
    \hline
    Ruby developer &
    Automatically run regression tests on two versions of the code under version control &
    I won't have to specify where the versions are, I can let it work that out itself \\
    \hline
    Ruby developer &
    Test basic program semantics (whitebox testing) &
    Two versions of the same code may have the same tested functionality, but they could be wrong in other ways \\
    \hline
    Ruby developer &
    Test my code across multiple computers at once &
    Parallelisation would allow for more tests to be created in less time, either speeding up the test cycle or allowing it to be more rigorous. \\
    \hline
    \end{tabular}
  \subsection{Future Enhancements}
    \begin{tabular}{| c | p{\colwidth} | p{\colwidth} |}
    \hline
    \textbf{As a...} & \textbf{I need to...} & \textbf{Because...} \\
    \hline
    Generic user &
    Use a website to interact with the testing &
    I want to learn how to test and therefore what good tests should look like. \\
    \hline
    Ruby developer &
    Have additional options to generate the tests, for example breadth-first and random-directed &
    My program may respond better to different traversal methods \\
    \hline
    \end{tabular}

\section{Choice of Language}
  Initially the project offered a choice of three languages to target: JavaScript, Python or Ruby. The table below is a comparison of their various features.

  \begin{tabular}{l | c | c | c}
  & Javascript & Python & Ruby \\
  \hline
  Group experience & 4 & 3 & 0 \\
  Typing & Weak, Duck & Strong, Duck & Duck \\
  Purely Object Oriented & No & No & Yes \\
  Functional & No & Yes & Yes \\
  \end{tabular}
  
These language are all duck typed\footnote{If it walks like a duck and quacks like a duck then it must be a duck}, meaning that an object's current set of variables and functions determines its semantics. When writing tests, the finished code must be 'concrete', which is a difficult challenge to overcome when an object is determined at run-time.
All three allow object-oriented approaches, but Ruby is the only one which is purely object-oriented, the other two having `raw' types, such as integers. Python and JavaScript would therefore need further processing to determine a variable's type than Ruby, making Ruby the easier language to work with.

The main disadvantage of Ruby is that none of the group had used it previously, whereas some members had considerable experience with the other languages. This turned out to be an advantage, as we all started off on the same level and helped each other learn along the way. Ruby is also a good language to learn, as it is similar to other languages which all members knew.

\section{Choice of Test Method to Implement}
  There are a number of types of tests we could have produced with SpLATS.
  The two main methods of testing are whitebox (testing the components) and blackbox (testing the application as a whole).
  Because Ruby is duck-typed, we chose blackbox testing as whitebox testing is limited to generic conditions, which we could have implemented as an extension.
  [examples of whitebox here]
