\chapter{Features}

\def \colwidth {0.35\textwidth}
\section{User Stories}
  Below is an extract from the first report explaining what the requirements are.
  These have been modified slightly to take into consideration how the requirements have changed as the project has evolved.
  \subsection{Minimum Requirements}
    \begin{tabular}{| c | p{\colwidth} | p{\colwidth} |}
    \hline
    \textbf{As a...} & \textbf{I need to...} & \textbf{Because...} \\
    \hline
    Ruby developer &
    Find out if two versions of my code have the same functionality &
    Any changes to the codebase should not break existing code. \\
    \hline
    Ruby developer &
    Set configuration options to select which classes and/or methods to test &
    I won't necessarily want to test the entire system \\
    \hline
    Ruby developer &
    Inspect code coverage of generated tests &
    I need to know how much of my code has been tested \\
    \hline
    Ruby developer &
    Reproduce tests &
    A test will highlight issues, I will change the code and then want to run the same tests to check the problem has disappeared. \\
    \hline
    Ruby developer &
    Use a command line interface to interact with the system &
    It's the quickest method for me to run tests and is easily automated, eg, by git bisect \\
    \hline
    \end{tabular}
  \subsection{Extensions}
    \begin{tabular}{| c | p{\colwidth} | p{\colwidth} |}
    \hline
    \textbf{As a...} & \textbf{I need to...} & \textbf{Because...} \\
    \hline
    Ruby developer &
    Use a graphical interface to interact with the system &
    If I'm not used to command line interfaces, it will be the easiest way for me to use the system. \\
    \hline
    Ruby developer &
    Automatically run regression tests on two versions of the code under version control &
    I won't have to specify where the versions are, I can let it work that out itself \\
    \hline
    Ruby developer &
    Test basic program semantics (whitebox testing) &
    Two versions of the same code may have the same tested functionality, but they could be wrong in other ways \\
    \hline
    Ruby developer &
    Test my code across multiple computers at once &
    Parallelisation would allow for more tests to be created in less time, either speeding up the test cycle or allowing it to be more rigorous. \\
    \hline
    \end{tabular}
  \subsection{Future Enhancements}
    \begin{tabular}{| c | p{\colwidth} | p{\colwidth} |}
    \hline
    \textbf{As a...} & \textbf{I need to...} & \textbf{Because...} \\
    \hline
    Generic user &
    Use a website to interact with the testing &
    I want to learn how to test and therefore what good tests should look like. \\
    \hline
    Ruby developer &
    Have additional options to generate the tests, for example breadth-first and random-directed &
    My program may respond better to different traversal methods \\
    \hline
    \end{tabular}

\section{Choice of Language}
  Initially the project offered a choice of three languages to target: JavaScript, Python or Ruby.
  These languages are all duck typed\footnote{If it quacks like a duck, it's a duck}, thus all introducing similar issues with automatically generating tests, namely that the finished code must be `concrete'.
  All three allow object-oriented approaches, but Ruby is the only one which is purely object-oriented, the other two having `raw' types, such as integers.
  Python and Javascript therefore would require distinguishing between the two classes of variable, whereas Ruby would be easier to deal with.

  The main disadvantage of Ruby is that none of the group had used it previously, whereas some members had considerable experience with the other languages.
  This did not prove to be too much of a barrier, it was relatively easy to learn as the group had all used similar languages.

  \begin{tabular}{l | c | c | c}
  & Javascript & Python & Ruby \\
  \hline
  Group experience & 4 & 3 & 0 \\
  Typing & Weak, Duck & Strong, Duck & Duck \\
  Purely Object Oriented & No & No & Yes \\
  Functional & No & Yes & Yes \\
  \end{tabular}

\section{Choice of Test Method to Implement}
  There are a number of types of tests we could have produced with SpLATS.
  The two main methods of testing are whitebox\footnote{Testing the components} and blackbox\footnote{Testing the application as a whole} testing.
  We chose blackbox testing, with the option of implementing some whitebox testing as an extension.
  Because Ruby is dynamically typed, the types of whitebox testing which can be implemented are limited to generic conditions.
  [examples here]
